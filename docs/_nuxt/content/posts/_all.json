[
  {
    "title": "Reducing Risk in Frontend Development with Docker",
    "stage": "draft",
    "tags": "nodejs, docker, frontend",
    "comments": true,
    "theme": "queenblue",
    "meta": {
      "index": 0,
      "fileName": "2018-04-18-reducing-risk-in-frontend-development-with-docker.md",
      "section": "/",
      "dirName": "/posts"
    },
    "date": "2018-04-18",
    "path": "/posts/posts/reducing-risk-in-frontend-development-with-docker",
    "permalink": "/posts/reducing-risk-in-frontend-development-with-docker",
    "anchors": [],
    "body": "<p>You and your team have been working on a website for the last couple of weeks, everything is good. But now there’s a new team member and they need to get their machine setup.</p>\n<p>Perhaps you’d goto to the NodeJS website and download whatever version, run the installer and attempt to install the tools for your project.</p>\n<p>Or maybe you’ve discovered that you need a better way to manage the versions of nodejs you need. So you go an install Nodist or Nvm depending on your operating system.</p>\n<p>Then you’d try and install the projects tools, because you’re a smart cookie you’ve described all this in your <code>package.json</code>. Hopeful faces abound as you run <code>npm install</code>.</p>\n<p>But now you’re experiencing mysterious installation issues, pngquant won’t install for some reason, node-sass can’t find some binding thing, and there’s a problem with something being too long.</p>\n<p>If only there was a more reliable way to get a new team member up and running with the project, A way to ensure that your project doesn’t rely on 3rd party repositories to make a build.</p>\n<p>There is, here’s what I’ve learnt.</p>\n<h2>Engine Version Managers</h2>\n<p>New nodejs versions are released frequently, mostly with new shiny features.</p>\n<p>So you’d have to ensure that once you got everything working, that you also specified what version of node to use.</p>\n<p>They work nicely on macosx and linux, because bash is awesome. but bash doesn’t exist on windows… so yeah, you’ll be managing two sets of manifests to describe the environment.</p>\n<h2>Virtual Machines</h2>\n<p>Five years ago, teams working on Django, Symphony, Ruby on Rails or Laravel would use something like Virtualbox (kvm, VMWare, etc) to bake an operating system, the project and its dependencies. You’d end up with an image that could be anywhere from 1-4gb depending on your choice of operating system.</p>\n<p>Windows and .Net developers however seem to handle this differently. I’ve never met or heard of anyone in that area creating a virtual machine containing Windows, IIS and MSSQL, probably because they’re used to downloading and storing dependencies in their project since the dawn of time, or more likely because such an image would end up being 20-60gb.</p>\n<p>If you didn’t use Vagrant, your virtual machine image is now ready for use.</p>\n<p>I actually used Vagrant in the past to simulate my production environment while coding. It’s great way to be exposed to production problems sooner, which means you won’t code your self into a corner because you didn’t realise x library doesn’t communicate across the network layer.</p>\n<p>But it’s slow. start up times are slow, host &lt;-&gt; vm file sync is slow and tricky and running even one vm uses up huge amounts of host memory.</p>\n<h2>Primary Risks</h2>\n<p>Show stoppers I’ve encountered:</p>\n<ul>\n<li>package author removes their package from npm (padleft)</li>\n<li>packages have post install compile steps, which the package author isn’t mitigating or hasn’t tested. Post build step performs network operations <em>will</em> fail.</li>\n<li>Our internet connection died because Telstra technician unilaterally decides to unplug our router/modem</li>\n<li>Some problem with intermediate caching on our machines is causing an incorrect package to be installed.</li>\n<li>Python wasn’t installed, so node-gyp doesn’t run, so can’t install node-sass.</li>\n<li>Node-gyp wasn’t installed globally.</li>\n<li>Random version of MSbuild wasn’t installed, some post install build process defined a node-gyp step that requires it.</li>\n<li>Git wasn’t installed, or more precisely it was un-installed and team member decided that source tree internal git over http was good enough.</li>\n<li>Some post build processes attempt to clean-up, but can’t because some aspects of windows don’t like paths longer than 256 characters.</li>\n<li>Package author doesn’t like windows, won’t account for it and is hostile to any suggestions that their architecture contributes to the monumental amount of bug tickets regarding installation of their package.</li>\n</ul>\n<p>These are just the ones I can remember, but to narrow them down into defined domains lets call them:</p>\n<ul>\n<li>“hostile deprecation”</li>\n<li>“network dependant”</li>\n<li>“ignorant post installation”</li>\n<li>“obscure system requirements”</li>\n</ul>\n<h3>Hostile Deprecation</h3>\n<p>every time you <code>npm i</code> or <code>pip install</code> or <code>bundle install</code> or <code>nuget install</code> you’re at the mercy of people like the author of <code>pad-left</code> or <code>imagemin</code>.</p>\n<p>Some of these authors are doe eyed enthusiastic people, they’ve yet to encounter what a colleague of mine explained to me as:</p>\n<p class=\"quote\">We are like diamonds, slowly eroded by the persistent drips of reality into thin lubricating substance that keeps software running smoothly.\n<em>– Anon Colleague</em></p>\n<p>What’s that? you can’t install a package and you have to create a prod build for deployment in an hour… oh what a shame.</p>\n<h2>Where to from here?</h2>\n<p>Over the last two years at Fusion, I’ve had to move outside the well crafted world of linux into that of MacOSx and Windows 7 and 10. Each of these systems have different ways of doing things on the filesystem, they have different ways of interpreting code and while NodeJS claims to be cross-platform (and it is), the reality is that most module authors are on linux or macosx, the automated tests they write rarely run cross platform or on multiple versions of node.</p>\n<p>As a frontend developer there are some things I’ve learnt with regards to the tooling we use, the solutions I came up with as I reached our current game plan were influenced by what I learnt while commercially developing Django projects.</p>\n"
  },
  {
    "title": "Automation, what I've learnt this year.",
    "stage": "draft",
    "tags": "nodejs, webpack, browserify, es6, selenium, vuejs",
    "icon": "info_outline",
    "meta": {
      "index": 1,
      "fileName": "2016-01-01-automation-what-i-have-learnt.md",
      "section": "/",
      "dirName": "/posts"
    },
    "date": "2016-01-01",
    "path": "/posts/posts/automation-what-i-have-learnt",
    "permalink": "/posts/automation-what-i-have-learnt",
    "anchors": [],
    "body": "<p>This year (and the next) mark the time in my growth where I become more pragmatic in my world view. Evolution and survival of the most pragmatic.</p>\n<p>There is more focus on creating systems for people.</p>\n<h2>Automation</h2>\n<p>I really dislike checklists… a lot.</p>\n<p>So if I can turn a checklist into code, I will. Now I have more time to work with the team to overcome feature obstacles.</p>\n<p>Checklists as code are:</p>\n<ul>\n<li>git hooks</li>\n<li>linters</li>\n<li>e2e tests</li>\n<li>tools that generate things</li>\n<li>deployment code</li>\n</ul>\n<h3>Somethings can’t be autometed (yet)</h3>\n<p>I’ve discovered some checklists are too expensive as code.</p>\n<p><strong>visual regression testing</strong></p>\n<p>Here we found that a tool like wraith to publish incremental snapshots over the life of a project is great for quickly highlight changes. A designer or developer can then make the call if the change is acceptable.</p>\n<p><strong>Unused Code</strong></p>\n<p>Often styles and javascript are created for components that may only come to life when a CMS user enables a setting or adds certain types of content to the page.</p>\n<p>In this case we’ve found that a simple component library gives quick indication about what css/js relates to what html mark-up.</p>\n<p>Ideally a developer should not leave dead code in the project.</p>\n<h2>Webpack</h2>\n<ul>\n<li>webpack. the hero we need not the one we deserve.</li>\n<li>speed differences with <code>gulp + browserify</code> vs <code>webpack dev server</code> are day and night. Gulp is 20secs everytimg, webpack has an initial time cost, but each change thereafter is relfective of affected code.</li>\n<li>instead of <code>scriptjs</code> loading cdn libs, use <code>system.import(/* webpackChunkName: 'vendor/jquery' */ @vendor/jquery')</code>\n<ul>\n<li>cdn might change over next 3years. Most commerical projects are legacy the moment they are deployed. No one likes working on them, so don’t make them fragile.</li>\n<li>assets can now easily be fingerprinted. yay <code>[chunkhash]</code>.</li>\n<li>the magic comment means it’s also lazy loaded.</li>\n</ul>\n</li>\n</ul>\n<h2>Gulp</h2>\n<ul>\n<li>Gulp is one of those things. It starts out small, quickly turns into a train wreck and your holding all the pieces.</li>\n<li>Most seek to create a black box of tasks, reality is they end up with a mountain of unmaintainable code sparse of desired features… because streams.</li>\n<li>For someone who spends their time looking at directory trees and file managers, It’s a mental model that makes sense to the mind incrementally chipping away at a problem.</li>\n<li>Errors are swallowed.</li>\n<li>Most people don’t even know how it really works, therefore most of the <code>gulpfiles</code> I’ve looked into are similar to what I imagine a forensics team encounters at mass murder scenes.</li>\n<li>streams are awesome. when used for the right scenario.</li>\n</ul>\n"
  },
  {
    "title": "Wintersmith Plugin. Mounter",
    "stage": "published",
    "tags": "nodejs, wintersmith, plugin",
    "icon": "extension",
    "comments": true,
    "meta": {
      "index": 2,
      "fileName": "2014-05-11-wintersmithplugin-externalmounter.md",
      "section": "/",
      "dirName": "/posts"
    },
    "date": "2014-05-11",
    "path": "/posts/posts/wintersmithplugin-externalmounter",
    "permalink": "/posts/wintersmithplugin-externalmounter",
    "anchors": [],
    "body": "<p>So I’ve just created a plugin for wintersmith, aimed at utilising my <code>bower_components</code> or <code>node_modules</code> directory from outside\nmy contents directory. Really though, you could use any directory as an additional source of content for wintersmiths <code>content tree</code>.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">me@machine:~/Projects/this/one $ mythical-ls\n\tbower_components\n\tnode_modules\n\tsrc\n\t\tassets\n\t\t\tscss\n\t\tconfig\n\t\tcontents\n\t\t\tarticles\n\t\t\tetc\n\t\t\t<span class=\"token punctuation\">..</span>.\n\t\t\tindex.md\n\t\tplugins\n\t\ttemplates\n\t\ttests\n\t\tapp.coffee\n\tCNAME\n\tGruntfile.coffee\n\tbower.json\n\tpackage.json\n\treadme.md\n</code></pre>\n<p>At first I was just putting <code>bower_components</code> directly inside my <code>project/src/contents/assets/vendor/</code> and while this might be tenable for bower, it wasn’t clean, you might come up with other reasons.</p>\n<h4>Installation</h4>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> wintersmith-mounter\n</code></pre>\n<h4>Configuration</h4>\n<p>In your configuration file, describe the path you wish to mount external content at :</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">\n  <span class=\"token punctuation\">...</span>\n\n  <span class=\"token key atrule\">mounter</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">mounts</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">'/assets/vendor/'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">src</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'./bower_components'</span>\n\n  <span class=\"token punctuation\">...</span>\n</code></pre>\n<p>Now, any content inside <code>./bower_components</code> will be available in your templates,\njavascript or stylesheets under <code>/assets/vendor/</code></p>\n<h4>Contributing</h4>\n<p>Feel free to submit bug reports, pull requests over at <a href=\"http://github.com/airtonix/wintersmith-mounter\">http://github.com/airtonix/wintersmith-mounter</a></p>\n"
  },
  {
    "title": "Bust the cache out of it",
    "stage": "published",
    "tags": "nodejs, grunt, usemin, cache busting",
    "icon": "cloud",
    "comments": true,
    "published": true,
    "meta": {
      "index": 3,
      "fileName": "2014-05-01-bust-the-cache-out-of-it.md",
      "section": "/",
      "dirName": "/posts"
    },
    "date": "2014-05-01",
    "path": "/posts/posts/bust-the-cache-out-of-it",
    "permalink": "/posts/bust-the-cache-out-of-it",
    "anchors": [],
    "body": "<p>This will be a short one, the topic of cache busting isn’t new, it’s covered by a wide range of articles. What I’ll cover here is the basics and how I tackled a particular scenario.</p>\n<hr>\n<h3>Why cache busting?</h3>\n<p>It’s a strategy made popular due to how the majority of the www internet works, a story told with two major actors:</p>\n<ul>\n<li>Caching Proxies, many of which exist between your browser and the websites you visit.</li>\n<li>Your Browser: nuff said.</li>\n</ul>\n<p>Many of them are configured in different ways, but mostly they exist to alleviate the amount of data being moved around at the extremities.</p>\n<p>The affects on websites isn’t apparent until you try to update some external asset files (images, javascript, stylehseets, fonts, etc). When people visit your site in the initial version their browser and all the caching proxies saved copies of the assets. When you updated those assets, your browser and the caching proxies only determine if they need to get a new copy based on a few bits of meta data (most of which the average webserver doesn’t deliver). The end result is that your website starts having problems due to incorrect stylesheets, scripts and fonts.</p>\n<h3>An initial strategy</h3>\n<p>One of the first solutions to show up in response to this was to simply put a GET parameter after any asset you linked to :</p>\n<pre class=\"language-html\"><code class=\"language-html\">logo.png?cachebust={% now %}\n</code></pre>\n<p>Here in this example, I’m using preprocessed html templating language <code>jinja</code>. Simply inserting the current timestamp as a query param helps to fool some caching proxies and browsers to fetch the file again. They do this because they think the resource is dynamic.</p>\n<p>The problem with this is that some proxies and browsers ignore this and serve the same file again.</p>\n<h3>A strategy, robust</h3>\n<p>People with more perseverance sought a more robust strategy, one that would guarantee the correct file is delivered.</p>\n<p>It starts with the idea that your assets only change if you push new assets into the deployment workflow, so if they’re not changing between deployments and the proxy servers are ignoring GET parameters, then why don’t we change the file name each deployment only if the file changes?</p>\n<p>This is the goal of <code>grunt-usemin</code> and <code>grunt-rev</code>, two tools used with the Grunt task runner.</p>\n<h4>Peculiar problem of relative paths</h4>\n<p>The situation is that some of my pages in this website have images generated from something that looks at a directory and says “alrght, lets make a collection of images”, other pages I point at the image myself in the markdown. Sometimes it’s relative pathing, sometimes absolute.</p>\n<p>By default <code>grunt-usemin</code> only operates on absolute paths, assuming you’ll be keeping all your assets in a common location.</p>\n<p>To get all your files revved I ended up with the following :</p>\n<pre class=\"language-coffeescript\"><code class=\"language-coffeescript\">\n    <span class=\"token property\">useminPrepare</span><span class=\"token punctuation\">:</span>\n      <span class=\"token property\">dist</span><span class=\"token punctuation\">:</span>\n        <span class=\"token property\">src</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'&lt;%= paths.dist %>/**/*.html'</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token property\">rev</span><span class=\"token punctuation\">:</span>\n      <span class=\"token property\">dist</span><span class=\"token punctuation\">:</span>\n        <span class=\"token property\">files</span><span class=\"token punctuation\">:</span>\n          <span class=\"token property\">src</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token string\">'&lt;%= paths.dist %>/assets/js/{,*/}*.js'</span>\n            <span class=\"token string\">'&lt;%= paths.dist %>/assets/css/{,*/}*.css'</span>\n            <span class=\"token string\">'&lt;%= paths.dist %>/assets/font/{,*/}*.{ttf,eot,otf,woff,svg}'</span>\n            <span class=\"token string\">'&lt;%= paths.dist %>/{,**/}**.{png,jpg,jpeg,gif,webp,svg}'</span>\n          <span class=\"token punctuation\">]</span>\n\n    <span class=\"token property\">usemin</span><span class=\"token punctuation\">:</span>\n      <span class=\"token property\">options</span><span class=\"token punctuation\">:</span>\n        <span class=\"token property\">assetsDirs</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n          <span class=\"token string\">'&lt;%= paths.dist %>/**/*'</span>\n          <span class=\"token string\">'&lt;%= paths.dist %>/'</span>\n        <span class=\"token punctuation\">]</span>\n        <span class=\"token property\">patterns</span><span class=\"token punctuation\">:</span>\n          <span class=\"token property\">html</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token punctuation\">[</span><span class=\"token regex\">/(js\\/[\\w\\d-]*\\.js)/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Replacing javascript link\"</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">[</span><span class=\"token regex\">/(css\\/[\\w\\d-]*\\.css)/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Replacing stylesheet link\"</span><span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">[</span><span class=\"token regex\">/(img\\/[\\w\\d-]*\\.(png|jpeg|jpg|gif))/g</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Replacing image link\"</span><span class=\"token punctuation\">]</span>\n          <span class=\"token punctuation\">]</span>\n\n      <span class=\"token property\">html</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'&lt;%= paths.dist %>/**/*.html'</span><span class=\"token punctuation\">]</span>\n      <span class=\"token property\">css</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'&lt;%= paths.dist %>/assets/css/**/*.css'</span><span class=\"token punctuation\">]</span>\n\n</code></pre>\n<p>I believe the important parts are :</p>\n<ul>\n<li>\n<p><em>useminPrepare.dist.src</em>\n: Nothing occurs without this… pretty standard stuff, it just points useminPrepare at the collection of files to operate on.</p>\n</li>\n<li>\n<p><em>rev.dist.files.src -&gt; last item</em>\n: Need to be able to act on any image, regardless of where it is.</p>\n</li>\n<li>\n<p><em>usemin.options.patterns.html</em>\n: This overrides the default matching and applies simple pattern matching of my own that allows for matching relative paths, as long as they start with <code>img/</code>.</p>\n</li>\n</ul>\n<h3>Conclusion</h3>\n<p><em>Is it perfect?</em>\n: problaby not.</p>\n<p><em>Does it work?</em>\n: yes.</p>\n<p><em>What do I think can be improved?</em>\n:remove the need to be in an <code>img</code> folder.</p>\n<p>Without cache busting, your life as a web developer is considerably more stressful. Phone calls, tickets, whispers you shouldn’t have to deal with, they all start hanging on your shoulders.</p>\n"
  }
]